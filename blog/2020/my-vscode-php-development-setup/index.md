# My VSCode PHP Development Setup

September 17, 2020 by [Areg Sarkissian](https://aregsar.com/about)

[My VSCode PHP Development Setup](https://aregsar.com/blog/2020/my-vscode-php-development-setup)

In this post I will share the VSCode php development extensions and keybindings that I use.

My setup is based on resources listed at the end of this article.

I am consolidating and adapting the information from those resources for my own setup for future reference and for anyone who would like a quick setup guide.

## PHP Extensions

First thing to do is install the following VSCode extensions:

- `PHP Intelephense` extension by `Ben Mewburn`

- `PHP Debug` extension by `Felix Becker`

- `Better PHPUnit` extension by `calebporzio`

## Configuring VSCode with XDebug for debugging

Follow the following four steps to configure XDebug.

### Step 1

First we need to install the PHP XDebug extension:

```bash
# force install the extension
pecl install --force xdebug
# check that the xdebug shows in the list of PHP extensions
php -m
```

### Step 2

After that locate your php.ini file:

```bash
php --ini
```

This print the location `/usr/local/etc/php/7.4/php.ini` on my MacBook.

Opening up the file:

```bash
cat /usr/local/etc/php/7.4/php.ini
```

I see the extension shown at the top of the file:

```ini
zend_extension="xdebug.so"
```

According the to the XDebug documentation we need to include the full path of the PHP extensions directory.
Run `pecl config-get ext_dir` to get the full path of the PHP extensions directory.
On my Mac the output is: `/usr/local/lib/php/pecl/20190902`

We also need to add the setting to enable remote debugging and set the remote port number.
On my machine I run Laravel Valet which runs php-fpm on port 9000 so I set the XDebug remote port value to 9001.
These additions are shown below:

```ini
zend_extension="/usr/local/lib/php/pecl/20190902/xdebug.so"
xdebug.remote_enable=1
xdebug.remote_port=9001
```

> You can opt to add separate config file at `/usr/local/etc/php/7.4/conf.d/ext-xdebug.ini` instead and include those
> lines there. See resource articles for instructions.

### Step 3

Next open your shell configuration file which, for me is the `.zshrc` file, and add the following:

```ini
export XDEBUG_CONFIG="idekey=VSCODE"
```

### Step 4

Open VSCode from within your project directory.

```bash
cd myproject
code .
```

Open the debug panel by pressing `cmd+sh+d` keyboard shortcut.

Click on the `show` link where it says `show all automatic debug configurations`.
Click on add configuration and select `PHP` from the drop down.

This will add `launch.json` debugging configuration to your project with settings for XDebug listening on port 9000.
As mentioned before need to change the XDebug port value to 9001 since to avoid conflict with php-fpm running on port 9000.

The `.vscode/launch.json` configuration file generated by VSCode is shown here with the port number changed:

```json
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Listen for XDebug",
      "type": "php",
      "request": "launch",
      "port": 9001
    },
    {
      "name": "Launch currently open script",
      "type": "php",
      "request": "launch",
      "program": "${file}",
      "cwd": "${fileDirname}",
      "port": 9001
    }
  ]
}
```

## Running a XDebug debugging session from VSCode for a Laravel project

Now you are ready to add breakpoints to your project files and debug your application.

Do the following steps:

1-Run

```bash
php artisan serve
```

2-Open the VSCode debug panel and Click the "listen for XDebug" play button.
This launches the debugger toolbar and starts the debugger.
You can click the stop button to stop a session.
You can use the continue and step buttons to continue execution after hitting a breakpoint.

3- navigate to `http://localhost:8000` in your browser.
You should see your application in the browser.

4-If you inspect the page you should see a `XDEBUG_SESSION=VSCODE` cookie written by the response.
If you don't see the cookie try navigating to `http://localhost:8000?XDEBUG_SESSION_START=VSCODE` instead and make sure the response contains the cookie.

You can inspect cookies by using the browser developer tools.
Alternatively you can check if the debugger breakpoints are working as described below. If they aren't being hit, then it probably means the cookie is not set and you can try adding the the `XDEBUG_SESSION_START` query string to make it work.

To test breakpoints, set a break point on the line that returns the welcome view in `routes/web.php` file of a new Laravel project.

```php
Route::get('/', function () {
    return view('welcome'); //set breakpoint on this line
});
```

Now Refresh the page in the web browser and you should hit the breakpoint where you
can inspect variables and the stack trace. Click the continue button in the debugger toolbar to continue and return the response.

If the breakpoint doesn't get hit make sure the the response contains
the `XDEBUG_SESSION=VSCODE` cookie as indicated before by adding the `XDEBUG_SESSION_START` query string parameter to the request URL.

## Debugging using Valet

If you have Valet running then you don't need to run `php artisan serve`. Just follow the remaining steps of the previous section except navigate to `http://yourappname.test?XDEBUG_SESSION_START=VSCODE` instead.

> Without the XDEBUG_SESSION_START parameter the XDEBUG_SESSION cookie is not written to the response, when using Valet to serve our app. Once the cookie is written though, we don't need to add the XDEBUG_SESSION_START parameter to the browser requests anymore.

## XDebug Issue with Laravel Cookie Encryption

Laravel encrypts all cookies by default. Since the XDEBUG_SESSION cookie injected by the php extension is not encrypted by Laravel, there will be an exception thrown by the framework. These exceptions are caught by the framework so the request execution will continue and eventually your breakpoints will be hit and the response will be returned.

However if the `Exceptions` breakpoint and `Everything` breakpoint settings are enabled in the VSCode debugger then the thrown framework exceptions will break at the exception location making for an annoying debugging experience.

The exception breakpoint occurs here in the class `Illuminate\Encryption\Encrypter`:

```php
class Encrypter implements EncrypterContract
{
  protected function getJsonPayload($payload)
    {
        $payload = json_decode(base64_decode($payload), true);

        // If the payload is not valid JSON or does not have the proper keys set we will
        // assume it is invalid and bail out of the routine since we will not be able
        // to decrypt the given value. We'll also check the MAC for this encryption.
        if (! $this->validPayload($payload)) {
            //Exception is thrown here
            throw new DecryptException('The payload is invalid.');
        }

        if (! $this->validMac($payload)) {
            throw new DecryptException('The MAC is invalid.');
        }

        return $payload;
    }
}
```

And the exception is caught further up the stack in the class `Illuminate\Cookie\Middleware\EncryptCookies`:

```php
class EncryptCookies
{
    protected function decrypt(Request $request)
    {
        foreach ($request->cookies as $key => $cookie) {
            if ($this->isDisabled($key)) {
                continue;
            }

            try {
                $value = $this->decryptCookie($key, $cookie);

                $hasValidPrefix = strpos($value, CookieValuePrefix::create($key, $this->encrypter->getKey())) === 0;

                $request->cookies->set(
                    $key, $hasValidPrefix ? CookieValuePrefix::remove($value) : null
                );
            } catch (DecryptException $e) {
                //The cookie decryption Exception is caught here and execution continues
                $request->cookies->set($key, null);
            }
        }

        return $request;
    }
 }
```

One solution to avoid these exception breakpoints will be to disable those VSCode breakpoint settings.
In the Breakpoints sub panel of the debug side panel in VSCode you can uncheck the `Exceptions` checkbox to avoid breaking on any exceptions.

However If you like to break on valid framework exceptions you have another option besides turning off exception breakpoints.

In you Laravel application you will have a `App\Http\Middleware\EncryptCookies` class shown below:

```php
class EncryptCookies extends Middleware
{
    /**
     * The names of the cookies that should not be encrypted.
     *
     * @var array
     */
    protected $except = [
       //
    ];
}
```

You can add cookies that should not be decrypted in the request:
Here you can add the XDebug session cookie to tell Laravel it should ignore that cookie.

Once set, the XDEBUG_SESSION cookie decryption exception will not happen.

```php
class EncryptCookies extends Middleware
{
    /**
     * The names of the cookies that should not be encrypted.
     *
     * @var array
     */
    protected $except = [
       'XDEBUG_SESSION'
    ];
}
```

Finally, sometimes there might be caches cookies from other debug sessions that are leftover that will cause the cookie decryption exception. You can manually delete these cookies using your browser tools to avoid the exception breakpoint.

For example since I also use PHPStorm I somehow had a cookie named `Phpstorm-b639e020` being sent in the request that I removed to fix the decryption exception I was getting when Laravel was trying to decrypt this cookie.

## How XDebug works with the VSCode Debugger

The XDebug extension running on the server collaborates with the VSCode installed PHP Debug extension to execute a debug session.
Every time a request is made from the browser to the server a new XDebug session is started which completes when the response is returned to the browser.

Below I detail the steps that happen when a XDebug session is established and the communication that occurs between the PHP server with the XDebug extension running on the server and the VSCode debug extension server in VSCode:

1 - run\start the php server (php artisan serve running on port 8000) or (laravel Valet\nginx\php-fpm running on port 9000) with the php interpreter XDebug extension settings configured in php.ini

2- launch\start VSCode IDE debug extension server (runs on port 9001 based on the .vscode/launch.json settings not to conflict with php-fpm port)

3- Using the web browser, make a http request to the local php server at `localhost:8000` or `valethostedexample.test`
passing XDEBUG_SESSION_START=VSCODE in query string param to let the XDebug extension know that it is the start of a debug session.

example request when running php artisan serve on port 8000
http://localhost:8000?XDEBUG_SESSION_START=VSCODE

example request when running Valet which uses dnsmasq server to resolve .test domain to nginx port 80
http://valethostedexample.test?XDEBUG_SESSION_START=VSCODE

> Note when using the php artisan serve XDebug works even without including `XDEBUG_SESSION_START=VSCODE` in query string param. This will be further explained below.

4- the php interpreter XDebug extension will detect a XDebug session for VSCode based on passed `XDEBUG_SESSION_START=VSCODE` query param and will connect to the VSCODE IDE debugger extension running on port 9001

5-As the php interpreter executes the http request it communicates with the XDebug server running in the IDE to debug the executed code and finally returns the http response back to the browser. The php XDebug extension will inject a cookie `XDEBUG_SESSION=VSCODE` in the response.

6-we make an new request to the web server to continue our debug session that starts the flow in steps 3 to 5 all over again. The following requests will send the `XDEBUG_SESSION=VSCODE` cookie so the php XDebug extension on the server detects that the request should establish a XDebug session again. So the XDEBUG_SESSION_START query string parameter in not required anymore after the first request (It can be removed from the query string although wont hurt if it remains)

> Note: When using Laravel valet to serve our app, we need to add XDEBUG_SESSION_START=VSCODE to the query string parameter when making the first request (http://valethostedexample.test?XDEBUG_SESSION_START=VSCODE).
> However when we use php artisan serve to serve our app, by default the first response will send back the XDEBUG_SESSION cookie without needing the XDEBUG_SESSION_START query string parameter to be present in the first request.Somehow the server detects XDebug session without XDEBUG_SESSION_START when serving on localhost. The requests after the first request will include the XDEBUG_SESSION cookie just as in the case when serving using Valet.

[understanding-and-using-xdebug](https://crosp.net/blog/software-development/web/php/understanding-and-using-xdebug-with-phpstorm-and-magento-remotely) has nice diagrams showing the XDebug web server and IDE debug session negotiation process.

## Configuring vscode for phpunit testing

To run your phpunit tests from within vscode, open the terminal by selecting the `ctrl+backtick` keyboard shortcut then type in `phpunit` in the terminal window to execute the tests.

If you have the `Better PHPUnit` vscode extension installed, you can click in the test class or test methods in your phpunit test files and execute specific tests by typing `phpunit` in the command panel.
The command panel is accessible via the `cmd+sh+p` keyboard shortcut.

Alternatively you can use the `Better PHPUnit` extensions keyboard shortcuts to run tests.
I have remapped those shortcuts to the shortcuts described in the laracasts video mentioned above.
To do that you can open keyboard shortcuts UI from command pallete then
type `better phpunit` in the search box to bringup all the shortcuts for that extension.
I changed the `run` shortcut to `cmd+t` and the `run previous` to `cmd+sh+t`.

With these shortcuts, you can click in a test class or test method and select `cmd+t` to run the corresponding test.
If you navigate cursor to another location you can alway select `cmd+sh+t` to rerun the last test that you ran without having to go back and click in that class or method.

## Resources

https://tighten.co/blog/configure-vscode-to-debug-phpunit-tests-with-xdebug/

https://laracasts.com/series/visual-studio-code-for-php-developers

https://cleody.com/setup-xdebug-in-laravel-valet-with-php-7-3-and-phpstorm/
